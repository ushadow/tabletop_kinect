package edu.mit.yingyin.tabletop.models;

import java.util.ArrayList;
import java.util.List;
import java.util.logging.Logger;

import javax.vecmath.Point2f;
import javax.vecmath.Point3f;

import org.OpenNI.Point3D;
import org.OpenNI.StatusException;

import edu.mit.yingyin.calib.CalibModel;
import edu.mit.yingyin.tabletop.models.HandTracker.ManipulativeEvent.FingerEventType;
import edu.mit.yingyin.tabletop.models.HandTrackingEngine.IHandEventListener;

/**
 * <code>HandTracker</code> tracks hand events based on estimated hand model 
 * parameters, and maintains a reference to the table model.
 * @author yingyin
 *
 */
public class HandTracker {
  /**
   * An event generated by a finger.
   * @author yingyin
   *
   */
  public static class ManipulativeEvent {
    public enum FingerEventType {PRESSED, RELEASED};
    
    public int frameID;
    /**
     * Position on depth image and position on display.
     */
    public Point3f posImage;
    public Point2f posDisplay;
    public FingerEventType type;
    
    public ManipulativeEvent(Point3f posImage, Point2f posDisplay,
        int frameID, FingerEventType type) { 
      this.posImage = posImage;
      this.posDisplay = posDisplay;
      this.frameID = frameID;
      this.type = type;
    }
    
    public String toString() {
      return String.format("Image positon = " + posImage + 
          " Display position = " + posDisplay + "\n");
    }
  }
  
  public static class DiecticEvent {
    private Point3D[] pointingLocationsI, pointingLocationsW;
    private Point2f[] pointingLocationsD;
    
    /**
     * 
     * @param imagePoints
     * @param worldPoints the length of pointingLocationsI and 
     *    pointingLocationsW should be the same.
     */
    public DiecticEvent(Point3D[] imagePoints, 
                        Point3D[] worldPoints,
                        Point2f[] displayPoints) {
      pointingLocationsI = imagePoints;
      pointingLocationsW = worldPoints;
      pointingLocationsD = displayPoints;
    }
    
    public Point3D[] pointingLocationsI() {
      return copyArray(pointingLocationsI);
    }
    
    public Point3D[] pointingLocationsW() {
      return copyArray(pointingLocationsW);
    }
    
    /**
     * Caller should not change the returned value.
     * @return
     */
    public Point2f[] pointingLocationsD() {
      return pointingLocationsD;
    }
    
    private Point3D[] copyArray(Point3D[] points) {
      Point3D[] res = new Point3D[points.length];
      for (int i = 0; i < points.length; i++) {
        Point3D p = points[i];
        res[i] = new Point3D(p.getX(), p.getY(), p.getZ());
      }
      return res;
    }
  }

  private static final Logger LOGGER = Logger.getLogger(
      HandTracker.class.getName());
  private static final int DEBOUNCE_COUNT = 3;

  private List<IHandEventListener> listeners = 
      new ArrayList<IHandEventListener>();
  
  /** Counts the duration of contact or noncontact. */
  private int pressedCounter = 0, releasedCounter = 0;
  /** True if finger is pressed, false otherwise. */
  private boolean pressed = false;
  private CalibModel calibExample;
  private DiecticGestureHandler dgh = new DiecticGestureHandler();
  private OpenNIDevice openni;
  
  public HandTracker(CalibModel calibExample, OpenNIDevice openni) {
    this.calibExample = calibExample;
    this.openni = openni;
  }
  
  /**
   * Updates forelimbs information and generates events.
   * @param forelimbs information for all the forelimbs detected.
   * @param frameID frame ID for the current update.
   */
  public void update(List<Forelimb> forelimbs, int frameID) {
    List<ManipulativeEvent> fingerEventList = noFilter(forelimbs, frameID);
    if (fingerEventList != null && !fingerEventList.isEmpty()) {
      for (IHandEventListener l : listeners) 
        l.fingerPressed(fingerEventList);
    }
    try {
      List<Point3D> intersections = dgh.update(forelimbs);
      int size = intersections.size();
      Point3D[] intersectionsW = new Point3D[size];
      intersections.toArray(intersectionsW);
      Point3D[] intersectionsI = openni.convertRealWorldToProjective(
          intersectionsW);
      Point2f[] intersectionsD = new Point2f[size];
      for (int i = 0; i < size; i++) {
        Point3D imageP = intersectionsI[i];
        intersectionsD[i] = calibExample.imageToDisplayCoords(imageP.getX(), 
            imageP.getY());
      }
      DiecticEvent de = new DiecticEvent(intersectionsI, intersectionsW, 
          intersectionsD);
      for (IHandEventListener l : listeners)
        l.fingerPointed(de);
    } catch (StatusException e) {
      LOGGER.severe(e.getMessage());
    }
  }
  
  public void addListener(IHandEventListener l) {
    listeners.add(l);
  }
  
  public void removeListener(IHandEventListener l) {
    listeners.remove(l);
  }

  /**
   * No filtering of any detected fingertips.
   * @param forelimbs a list of forelimbs.
   * @param frameID frame ID.
   * @return a list of finger events.
   */
  public List<ManipulativeEvent> noFilter(List<Forelimb> forelimbs, int frameID) {
    List<ManipulativeEvent> fingerEventList = new ArrayList<ManipulativeEvent>();
    for (Forelimb forelimb : forelimbs) 
      for (Point3f tip : forelimb.getFingertipsI())
        fingerEventList.add(createFingerEvent(tip, frameID, 
                                              FingerEventType.PRESSED));
    return fingerEventList;
  }

  /**
   * Filters out finger pressed events.
   * @param forelimbs
   * @param frameID
   * @return
   */
  public List<ManipulativeEvent> filterPressed(List<Forelimb> forelimbs, 
                                         int frameID) {
    InteractionSurface table = InteractionSurface.instance();
    List<ManipulativeEvent> fingerEventList = new ArrayList<ManipulativeEvent>();
    
    if (table == null) 
      return fingerEventList;
    
    for (Forelimb forelimb : forelimbs) {
      for (Point3f tip : forelimb.getFingertipsI()) {
        float tipDepth = tip.z + Hand.FINGER_THICKNESS; 
        boolean inContact = table.isInContact((int)tip.x, (int)tip.y, tipDepth);
        if (inContact) {
          pressedCounter++;
          releasedCounter = 0;
        } else {
          releasedCounter++;
          pressedCounter = 0;
        }
        if (pressedCounter == DEBOUNCE_COUNT && !pressed) {
          pressed = true;
          fingerEventList.add(createFingerEvent(tip, frameID, 
                                                FingerEventType.PRESSED));
        } else if (releasedCounter == DEBOUNCE_COUNT && pressed) {
          pressed = false;
          fingerEventList.add(createFingerEvent(tip, frameID, 
                                                FingerEventType.RELEASED));
        }
      }
    }
    return fingerEventList;
  }
  
  private ManipulativeEvent createFingerEvent(Point3f posImage, int frameID, 
      FingerEventType type) {
    return new ManipulativeEvent(posImage, 
        calibExample.imageToDisplayCoords(posImage.x, posImage.y),
        frameID, type);
  }
  
}
